# continuous-integration

## Посилання на практичні роботи на GitHub Skills

[Hello GitHub Actions](https://github.com/alisha2112/skills-hello-github-actions)

[Publish Packages](https://github.com/alisha2112/skills-publish-packages)

## Збірка докер-образу front-end репозиторію та завантаження його у GitHub container registry

Вихідний репозиторій був порожнім, тому для коректної роботи CI/CD 
пайплайну (Pipeline) було створено базову структуру Front-end проєкту.
Це необхідно для того, щоб команди збірки та пакування у Docker мали
об'єкт виконання.
- файл package.json: створено файл конфігурації Node.js, у якому 
визначено скрипт "build". Це дозволяє виконати вимогу завдання щодо
запуску команди pnpm run build.
- файл Dockerfile: описує інструкції для створення Docker-образу 
(базовий образ node:alpine, копіювання файлів, встановлення залежностей),
що є необхідним для кроку docker/build-push-action.

### Реалізація GitHub Workflow

Основним етапом роботи стало створення файлу конфігурації .github/workflows/docker-build.yml.

#### Налаштування тригерів

Згідно з документацією GitHub Actions, було визначено секцію on, яка містить два типи тригерів:
1. workflow_dispatch: Додає можливість ручного запуску воркфлоу через інтерфейс GitHub (кнопка "Run workflow").
2. push: Автоматичний запуск при виконанні операції git push у наступні гілки:
- main — основна гілка.
- feature/* — використання символу підстановки (wildcard) дозволяє реагувати на будь-які гілки, назва яких починається з "feature/" (наприклад, feature/login, feature/styles).

#### Конфігурація середовища виконання

Воркфлоу містить одну задачу (job) під назвою build-and-push-job, яка виконується 
на віртуальній машині ubuntu-latest. Для успішного завантаження образу в GitHub 
Container Registry (GHCR) було явно задано права доступу:
```bash
permissions:
  packages: write
  contents: read
```
Це надає автоматичному токену GITHUB_TOKEN дозвіл на запис у реєстр пакетів.

#### Аналіз кроків виконання
1. Клонування репозиторію - використано стандартний екшн для завантаження коду 
репозиторію у робочу директорію віртуальної машини.
2. Встановлення та збірка - відповідно до завдання, всі команди згруповано в один блок run (shell-скрипт):
- npm install -g pnpm — глобальне встановлення пакетного менеджера pnpm.
- pnpm install — встановлення залежностей проєкту.
- pnpm run build — збірка проєкту (виконує команду, прописану в package.json).
3. Авторизація в Registry - використано офіційний екшн для логіну в Docker реєстр.
- Registry: вказано ghcr.io (GitHub Container Registry).
- Username: використано контекстну змінну ${{ github.actor }}, яка автоматично 
підставляє ім'я користувача, що ініціював воркфлоу.
- Password: використано секрет ${{ secrets.GITHUB_TOKEN }}, який генерується 
GitHub автоматично для кожного запуску, що забезпечує безпеку без необхідності 
зберігати паролі вручну.
4. Збірка та пуш образу (docker/build-push-action):
- Context - вказано поточну директорію (.), де знаходиться Dockerfile.
- Push - значення true активує завантаження образу в реєстр після збірки.
- Tags - формування тегу реалізовано динамічно через контекст ${{ github.repository }}. 
Це дозволяє автоматично отримати рядок у форматі ім'я_користувача/ім'я_репозиторію.
- Результуючий тег: ghcr.io/${{ github.repository }}:latest.

#### Результати роботи
Після завантаження коду (git push) GitHub Actions автоматично ініціював виконання
Workflow. Усі кроки завершилися успішно. В розділі Packages репозиторію з'явився 
новий Docker-образ, саме це підтверджує те, що механізм CI/CD налаштовано правильно, 
оскільки код автоматично збирається, тестується (на етапі build) та пакується в 
контейнер, доступний для подальшого розгортання.




